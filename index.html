
<title>Menu Example</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style>
  body {
    padding: 20px;
    padding-bottom: 500px;
    font: 1em comic sans ms, arial;
    text-align: center;
  }
  ul {
    position: fixed;
    padding-left: 0;
  }
  ul li {
    list-style: none;
    padding: 10px;
    border-radius: 3px;
    width: 130px;
  }
  ul li.active {
    background: #019dff;
  }
  .content {
    margin-left: 200px;
  }
  .item {
    display: block;
    background: #eee;
    margin-bottom: 20px;
  }
  .item span {
    line-height: 300px;
  }
</style>

<ul>
  <li><a href="#item1">Item 1</a></li>
  <li><a href="#item2">Item 2</a></li>
  <li><a href="#item3">Item 3</a></li>
  <li><a href="#item4">Item 4</a></li>
  <li><a href="#item5">Item 5</a></li>
  <li><a href="#item6">Item 6</a></li>
  <li><a href="#item7">Item 7</a></li>
  <li><a href="#item8">Item 8</a></li>
  <li><a href="#item9">Item 9</a></li>
  <li><a href="#item10">Item 10</a></li>
</ul>
<div class="content">
  <h2>Scroll/Resize this page!</h2>
  <div class="item" id="item1"><span>Item 1</span></div>
  <div class="item" id="item2"><span>Item 2</span></div>
  <div class="item" id="item3"><span>Item 3</span></div>
  <div class="item" id="item4"><span>Item 4</span></div>
  <div class="item" id="item5"><span>Item 5</span></div>
  <div class="item" id="item6"><span>Item 6</span></div>
  <div class="item" id="item7"><span>Item 7</span></div>
  <div class="item" id="item8"><span>Item 8</span></div>
  <div class="item" id="item9"><span>Item 9</span></div>
  <div class="item" id="item10"><span>Item 10</span></div>
</div>

<script>!function (context, definition) {
  if (typeof require == 'function' && typeof exports == 'object' && typeof module == 'object') {
    module.exports = definition()
  } else if (typeof define == 'function' && typeof define.amd  == 'object') {
    define(definition)
  } else {
    context['top-most'] = definition()
  }
}(this, function () {
  var modules = {
    "/node_modules/css-install.js": "module.exports = function (text) {\n\tvar style = document.createElement('style')\n\tstyle.appendChild(document.createTextNode(text))\n\tdocument.getElementsByTagName('head')[0].appendChild(style)\n}",
    "/node_modules/jade-runtime.js": "\r\n/*!\r\n * Jade - runtime\r\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Lame Array.isArray() polyfill for now.\r\n */\r\n\r\nif (!Array.isArray) {\r\n  Array.isArray = function(arr){\r\n    return '[object Array]' == Object.prototype.toString.call(arr);\r\n  };\r\n}\r\n\r\n/**\r\n * Lame Object.keys() polyfill for now.\r\n */\r\n\r\nif (!Object.keys) {\r\n  Object.keys = function(obj){\r\n    var arr = [];\r\n    for (var key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        arr.push(key);\r\n      }\r\n    }\r\n    return arr;\r\n  }\r\n}\r\n\r\n/**\r\n * Merge two attribute objects giving precedence\r\n * to values in object `b`. Classes are special-cased\r\n * allowing for arrays and merging/joining appropriately\r\n * resulting in a string.\r\n *\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @return {Object} a\r\n * @api private\r\n */\r\n\r\nexports.merge = function merge(a, b) {\r\n  var ac = a['class'];\r\n  var bc = b['class'];\r\n\r\n  if (ac || bc) {\r\n    ac = ac || [];\r\n    bc = bc || [];\r\n    if (!Array.isArray(ac)) ac = [ac];\r\n    if (!Array.isArray(bc)) bc = [bc];\r\n    a['class'] = ac.concat(bc).filter(nulls);\r\n  }\r\n\r\n  for (var key in b) {\r\n    if (key != 'class') {\r\n      a[key] = b[key];\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Filter null `val`s.\r\n *\r\n * @param {*} val\r\n * @return {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction nulls(val) {\r\n  return val != null && val !== '';\r\n}\r\n\r\n/**\r\n * join array as classes.\r\n *\r\n * @param {*} val\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction joinClasses(val) {\r\n  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\r\n}\r\n\r\n/**\r\n * Render the given attributes object.\r\n *\r\n * @param {Object} obj\r\n * @param {Object} escaped\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.attrs = function attrs(obj, escaped){\r\n  var buf = []\r\n    , terse = obj.terse;\r\n\r\n  delete obj.terse;\r\n  var keys = Object.keys(obj)\r\n    , len = keys.length;\r\n\r\n  if (len) {\r\n    buf.push('');\r\n    for (var i = 0; i < len; ++i) {\r\n      var key = keys[i]\r\n        , val = obj[key];\r\n\r\n      if ('boolean' == typeof val || null == val) {\r\n        if (val) {\r\n          terse\r\n            ? buf.push(key)\r\n            : buf.push(key + '=\"' + key + '\"');\r\n        }\r\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\r\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\r\n      } else if ('class' == key) {\r\n        if (escaped && escaped[key]){\r\n          if (val = exports.escape(joinClasses(val))) {\r\n            buf.push(key + '=\"' + val + '\"');\r\n          }\r\n        } else {\r\n          if (val = joinClasses(val)) {\r\n            buf.push(key + '=\"' + val + '\"');\r\n          }\r\n        }\r\n      } else if (escaped && escaped[key]) {\r\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\r\n      } else {\r\n        buf.push(key + '=\"' + val + '\"');\r\n      }\r\n    }\r\n  }\r\n\r\n  return buf.join(' ');\r\n};\r\n\r\n/**\r\n * Escape the given string of `html`.\r\n *\r\n * @param {String} html\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escape = function escape(html){\r\n  return String(html)\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;');\r\n};\r\n\r\n/**\r\n * Re-throw the given `err` in context to the\r\n * the jade in `filename` at the given `lineno`.\r\n *\r\n * @param {Error} err\r\n * @param {String} filename\r\n * @param {String} lineno\r\n * @api private\r\n */\r\n\r\nexports.rethrow = function rethrow(err, filename, lineno, str){\r\n  if (!(err instanceof Error)) throw err;\r\n  if ((typeof window != 'undefined' || !filename) && !str) {\r\n    err.message += ' on line ' + lineno;\r\n    throw err;\r\n  }\r\n  try {\r\n    str =  str || require('fs').readFileSync(filename, 'utf8')\r\n  } catch (ex) {\r\n    rethrow(err, null, lineno)\r\n  }\r\n  var context = 3\r\n    , lines = str.split('\\n')\r\n    , start = Math.max(lineno - context, 0)\r\n    , end = Math.min(lines.length, lineno + context);\r\n\r\n  // Error context\r\n  var context = lines.slice(start, end).map(function(line, i){\r\n    var curr = i + start + 1;\r\n    return (curr == lineno ? '  > ' : '    ')\r\n      + curr\r\n      + '| '\r\n      + line;\r\n  }).join('\\n');\r\n\r\n  // Alter exception message\r\n  err.path = filename;\r\n  err.message = (filename || 'Jade') + ':' + lineno\r\n    + '\\n' + context + '\\n\\n' + err.message;\r\n  throw err;\r\n};\r\n",
    "/example.html-1.js": "\nvar topmost = require('./index')\nvar classes = require('classes')\n\nvar items = document.querySelectorAll('.item')\nvar tabs = document.querySelectorAll('ul > li')\nvar active = tabs[0]\n\ntopmost(items, function(el, i){\n\tclasses(active).remove('active')\n\tclasses(active = tabs[i]).add('active')\n})\n",
    "/index.js": "\nvar viewport = require('viewport')\nvar Emitter = require('emitter')\n\n/**\n * create a new TopCell\n * \n * @param {Array|Nodelist} items\n * @param {Function} [fn]\n * @return {TopCell}\n */\n\nmodule.exports = function(items, fn){\n\tvar cell = new TopCell(items)\n\tif (fn) cell.on('change', fn)\n\tcell.change()\n\treturn cell\n}\n\nfunction TopCell(els){\n\tthis.els = els\n\tviewport.on('resize', this.change, this)\n\tviewport.on('scroll', this.change, this)\n}\n\n/**\n * mixin emitter\n */\n\nEmitter(TopCell.prototype)\n\n/**\n * check if the top most node has changed. If it has a\n * \"change\" event will be emitted.\n */\n\nTopCell.prototype.change = function(){\n\tvar els = this.els\n\tfor (var i = 0, len = els.length - 1; i < len; i++) {\n\t\tif (bottom(els[i]) > 0) break\n\t}\n\tvar old = this.value\n\tvar top = els[i]\n\tif (top !== old) {\n\t\tthis.value = top\n\t\tthis.emit('change', top, i)\n\t}\n}\n\n/**\n * clean up\n */\n\nTopCell.prototype.destroy = function(){\n\tviewport.off('resize', this.change, this)\n\tviewport.off('scroll', this.change, this)\n}\n\nfunction bottom(node){\n\treturn node.getBoundingClientRect().bottom\n}",
    "/node_modules/github.com/component/classes/tarball/1.1.3/index.js": "/**\n * Module dependencies.\n */\n\nvar index = require('indexof');\n\n/**\n * Whitespace regexp.\n */\n\nvar re = /\\s+/;\n\n/**\n * toString reference.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nmodule.exports = function(el){\n  return new ClassList(el);\n};\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  if (!el) throw new Error('A DOM element reference is required');\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function(name){\n  // classList\n  if (this.list) {\n    this.list.add(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (!~i) arr.push(name);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function(name){\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  // classList\n  if (this.list) {\n    this.list.remove(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (~i) arr.splice(i, 1);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function(re){\n  var arr = this.array();\n  for (var i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function(name){\n  // classList\n  if (this.list) {\n    this.list.toggle(name);\n    return this;\n  }\n\n  // fallback\n  if (this.has(name)) {\n    this.remove(name);\n  } else {\n    this.add(name);\n  }\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function(){\n  var str = this.el.className.replace(/^\\s+|\\s+$/g, '');\n  var arr = str.split(re);\n  if ('' === arr[0]) arr.shift();\n  return arr;\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has =\nClassList.prototype.contains = function(name){\n  return this.list\n    ? this.list.contains(name)\n    : !! ~index(this.array(), name);\n};\n",
    "/node_modules/github.com/jkroso/viewport/tarball/0.1.4/index.js": "\nvar Emitter = require('emitter')\nvar events = require('event')\n\n// mixin emitter\nEmitter(exports)\n\nvar html = document.getElementsByTagName('html')[0]\n\nevents.bind(window, 'resize', function(e){\n\tsize()\n\tposition()\n\texports.emit('resize', exports)\n})\n\nevents.bind(window, 'scroll', function(){\n\tposition()\n\texports.emit('scroll', exports)\n})\n\n/**\n * Initialise\n */\n\nsize()\nposition()\n\n/**\n * Update the size attributes\n */\n\nfunction size(){\n\texports.height = html.clientHeight\n\texports.width = html.clientWidth\n}\n\n/**\n * Update the position attributes\n */\n\nfunction position(){\n\texports.top = window.scrollY\n\texports.left = window.scrollX\n\texports.right = exports.left + exports.width\n\texports.bottom = exports.top + exports.height\n}\n",
    "/node_modules/github.com/jkroso/emitter/tarball/0.7.0/index.js": "\r\nvar call = Function.prototype.call\r\n\r\nmodule.exports = Emitter\r\n\r\n/**\r\n * Generate a new Emitter or mixin methods to `obj`\r\n *\r\n *   var emitter = new Emitter\r\n *   var emitter = Emitter({})\r\n */\r\n\r\nfunction Emitter (obj) {\r\n\tif (obj) {\r\n\t\tfor (var prop in proto) {\r\n\t\t\tobj[prop] = proto[prop]\r\n\t\t}\r\n\t\treturn obj\r\n\t}\r\n}\r\n\r\nvar proto = Emitter.prototype\r\n\r\n/**\r\n * Generate an event. All arguments after `topic` will be passed to\r\n * the handlers\r\n *\r\n *   emitter.emit('event', new Date)\r\n *   \r\n * @param {String} topic the events topic\r\n * @param {Any} [...]\r\n * @return {this}\r\n */\r\n\r\nEmitter.prototype.emit = function(topic){\r\n\tvar cbs = this._events\r\n\tif (!(cbs && (cbs = cbs[topic]))) return this\r\n\tvar i = cbs.length\r\n\t// try avoid using apply for speed\r\n\tswitch (arguments.length) {\r\n\t\tcase 1: while (i) cbs[--i].call(cbs[--i]);break\r\n\t\tcase 2: while (i) cbs[--i].call(cbs[--i], arguments[1]);break\r\n\t\tcase 3: while (i) cbs[--i].call(cbs[--i], arguments[1], arguments[2]);break\r\n\t\tcase 4: while (i) cbs[--i].call(cbs[--i], arguments[1], arguments[2], arguments[3]);break\r\n\t\tdefault:while (i) {\r\n\t\t\tvar ƒ = cbs[--i]\r\n\t\t\ttopic = cbs[--i]\r\n\t\t\tcall.apply(ƒ, arguments)\r\n\t\t}\r\n\t}\r\n\treturn this\r\n}\r\n\r\n/**\r\n * Add a subscription under a topic name\r\n *\r\n *   emitter.on('event', function(data){})\r\n *   emitter.on('event') // implies emitter.on('event', emitter.onEvent)\r\n *   emitter.on('event', function(){this === emitter}, emitter)\r\n *   emitter.on('event', function(){this === emitter}) // the current context is the default\r\n *\r\n * @param {String} topic\r\n * @param {Function} fn to be called when the topic is emitted\r\n * @param {Object} context to call the the function with\r\n * @return {this}\r\n */\r\n\r\nEmitter.prototype.on = function(topic, fn, context){\r\n\tvar cbs = this._events || (this._events = {})\r\n\t// avoid mutating the old array\r\n\tcbs[topic] = cbs[topic]\r\n\t\t? [context || this, fn].concat(cbs[topic])\r\n\t\t: [context || this, fn]\r\n\r\n\treturn this\r\n}\r\n\r\n/**\r\n * Remove subscriptions\r\n *\r\n *   emitter.off() // clears all topics\r\n *   emitter.off('topic') // clears all handlers from the topic 'topic'\r\n *   emitter.off('topic', fn) // as above but only if the handler === fn\r\n *   emitter.off('topic', fn, window) // as above but only if the context is `window`\r\n *\r\n * @param {String} [topic]\r\n * @param {Function} [fn]\r\n * @param {Any} [context]\r\n * @return {this}\r\n */\r\n\r\nEmitter.prototype.off = function(topic, fn, context){\r\n\tvar cbs = this._events\r\n\tif (!cbs) return this\r\n\r\n\t// no filters\r\n\tif (topic == null) {\r\n\t\tfor (var i in cbs) delete cbs[i]\r\n\t} \r\n\t// just a topic\r\n\telse if (!fn) {\r\n\t\tdelete cbs[topic]\r\n\t} \r\n\telse {\r\n\t\tvar events = cbs[topic]\r\n\t\tif (!events) return this\r\n\t\tvar i = events.length\r\n\t\twhile (i--) {\r\n\t\t\tif (events[i--] !== fn) continue\r\n\t\t\t// if `context`, then it needs to match too\r\n\t\t\tif (context && events[i] !== context) continue\r\n\t\t\tevents = events.slice()\r\n\t\t\tevents.splice(i, 2)\r\n\t\t\tcbs[topic] = events\r\n\t\t}\r\n\t}\r\n\treturn this\r\n}\r\n\r\nEmitter.prototype.once = function(topic, fn, context){\r\n\tif (!fn) throw new Error('requires a function')\r\n\tvar self = this\r\n\treturn this.on(topic, function once() {\r\n\t\tfn.apply(this, arguments)\r\n\t\tself.off(topic, once)\r\n\t}, context)\r\n}\r\n\r\n/**\r\n * test if a subscription is present\r\n *\r\n * @param {String} topic\r\n * @param {Function} [ƒ=*]\r\n * @param {Any} [ctx=*]\r\n * @return {Boolean}\r\n */\r\n\r\nEmitter.prototype.hasSubscription = function(topic, ƒ, ctx){\r\n\tvar cbs = this._events\r\n\tif (!cbs) return false\r\n\tif (!(cbs = cbs[topic])) return false\r\n\tif (!ƒ) return true\r\n\tfor (var i = 0, len = cbs.length; i < len; i+=2) {\r\n\t\tif (cbs[i + 1] === ƒ) {\r\n\t\t\tif (ctx == null || ctx === cbs[i]) return true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}",
    "/node_modules/github.com/component/indexof/tarball/master/index.js": "\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};",
    "/node_modules/github.com/jkroso/Emitter/tarball/0.7.0/index.js": "\r\nvar call = Function.prototype.call\r\n\r\nmodule.exports = Emitter\r\n\r\n/**\r\n * Generate a new Emitter or mixin methods to `obj`\r\n *\r\n *   var emitter = new Emitter\r\n *   var emitter = Emitter({})\r\n */\r\n\r\nfunction Emitter (obj) {\r\n\tif (obj) {\r\n\t\tfor (var prop in proto) {\r\n\t\t\tobj[prop] = proto[prop]\r\n\t\t}\r\n\t\treturn obj\r\n\t}\r\n}\r\n\r\nvar proto = Emitter.prototype\r\n\r\n/**\r\n * Generate an event. All arguments after `topic` will be passed to\r\n * the handlers\r\n *\r\n *   emitter.emit('event', new Date)\r\n *   \r\n * @param {String} topic the events topic\r\n * @param {Any} [...]\r\n * @return {this}\r\n */\r\n\r\nEmitter.prototype.emit = function(topic){\r\n\tvar cbs = this._events\r\n\tif (!(cbs && (cbs = cbs[topic]))) return this\r\n\tvar i = cbs.length\r\n\t// try avoid using apply for speed\r\n\tswitch (arguments.length) {\r\n\t\tcase 1: while (i) cbs[--i].call(cbs[--i]);break\r\n\t\tcase 2: while (i) cbs[--i].call(cbs[--i], arguments[1]);break\r\n\t\tcase 3: while (i) cbs[--i].call(cbs[--i], arguments[1], arguments[2]);break\r\n\t\tcase 4: while (i) cbs[--i].call(cbs[--i], arguments[1], arguments[2], arguments[3]);break\r\n\t\tdefault:while (i) {\r\n\t\t\tvar ƒ = cbs[--i]\r\n\t\t\ttopic = cbs[--i]\r\n\t\t\tcall.apply(ƒ, arguments)\r\n\t\t}\r\n\t}\r\n\treturn this\r\n}\r\n\r\n/**\r\n * Add a subscription under a topic name\r\n *\r\n *   emitter.on('event', function(data){})\r\n *   emitter.on('event') // implies emitter.on('event', emitter.onEvent)\r\n *   emitter.on('event', function(){this === emitter}, emitter)\r\n *   emitter.on('event', function(){this === emitter}) // the current context is the default\r\n *\r\n * @param {String} topic\r\n * @param {Function} fn to be called when the topic is emitted\r\n * @param {Object} context to call the the function with\r\n * @return {this}\r\n */\r\n\r\nEmitter.prototype.on = function(topic, fn, context){\r\n\tvar cbs = this._events || (this._events = {})\r\n\t// avoid mutating the old array\r\n\tcbs[topic] = cbs[topic]\r\n\t\t? [context || this, fn].concat(cbs[topic])\r\n\t\t: [context || this, fn]\r\n\r\n\treturn this\r\n}\r\n\r\n/**\r\n * Remove subscriptions\r\n *\r\n *   emitter.off() // clears all topics\r\n *   emitter.off('topic') // clears all handlers from the topic 'topic'\r\n *   emitter.off('topic', fn) // as above but only if the handler === fn\r\n *   emitter.off('topic', fn, window) // as above but only if the context is `window`\r\n *\r\n * @param {String} [topic]\r\n * @param {Function} [fn]\r\n * @param {Any} [context]\r\n * @return {this}\r\n */\r\n\r\nEmitter.prototype.off = function(topic, fn, context){\r\n\tvar cbs = this._events\r\n\tif (!cbs) return this\r\n\r\n\t// no filters\r\n\tif (topic == null) {\r\n\t\tfor (var i in cbs) delete cbs[i]\r\n\t} \r\n\t// just a topic\r\n\telse if (!fn) {\r\n\t\tdelete cbs[topic]\r\n\t} \r\n\telse {\r\n\t\tvar events = cbs[topic]\r\n\t\tif (!events) return this\r\n\t\tvar i = events.length\r\n\t\twhile (i--) {\r\n\t\t\tif (events[i--] !== fn) continue\r\n\t\t\t// if `context`, then it needs to match too\r\n\t\t\tif (context && events[i] !== context) continue\r\n\t\t\tevents = events.slice()\r\n\t\t\tevents.splice(i, 2)\r\n\t\t\tcbs[topic] = events\r\n\t\t}\r\n\t}\r\n\treturn this\r\n}\r\n\r\nEmitter.prototype.once = function(topic, fn, context){\r\n\tif (!fn) throw new Error('requires a function')\r\n\tvar self = this\r\n\treturn this.on(topic, function once() {\r\n\t\tfn.apply(this, arguments)\r\n\t\tself.off(topic, once)\r\n\t}, context)\r\n}\r\n\r\n/**\r\n * test if a subscription is present\r\n *\r\n * @param {String} topic\r\n * @param {Function} [ƒ=*]\r\n * @param {Any} [ctx=*]\r\n * @return {Boolean}\r\n */\r\n\r\nEmitter.prototype.hasSubscription = function(topic, ƒ, ctx){\r\n\tvar cbs = this._events\r\n\tif (!cbs) return false\r\n\tif (!(cbs = cbs[topic])) return false\r\n\tif (!ƒ) return true\r\n\tfor (var i = 0, len = cbs.length; i < len; i+=2) {\r\n\t\tif (cbs[i + 1] === ƒ) {\r\n\t\t\tif (ctx == null || ctx === cbs[i]) return true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}",
    "/node_modules/github.com/component/event/tarball/0.1.0/index.js": "\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  if (el.addEventListener) {\n    el.addEventListener(type, fn, capture);\n  } else {\n    el.attachEvent('on' + type, fn);\n  }\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  if (el.removeEventListener) {\n    el.removeEventListener(type, fn, capture);\n  } else {\n    el.detachEvent('on' + type, fn);\n  }\n  return fn;\n};\n"
  }
  
  var aliases = {
    "/example.html": "/example.html-1.js",
    "/node_modules/classes/index.js": "/node_modules/github.com/component/classes/tarball/1.1.3/index.js",
    "/node_modules/viewport/index.js": "/node_modules/github.com/jkroso/viewport/tarball/0.1.4/index.js",
    "/node_modules/emitter/index.js": "/node_modules/github.com/jkroso/emitter/tarball/0.7.0/index.js",
    "/node_modules/github.com/component/classes/tarball/1.1.3/node_modules/indexof/index.js": "/node_modules/github.com/component/indexof/tarball/master/index.js",
    "/node_modules/github.com/jkroso/viewport/tarball/0.1.4/node_modules/emitter/index.js": "/node_modules/github.com/jkroso/Emitter/tarball/0.7.0/index.js",
    "/node_modules/github.com/jkroso/viewport/tarball/0.1.4/node_modules/event/index.js": "/node_modules/github.com/component/event/tarball/0.1.0/index.js"
  }
    
  /**  
   * give each module an identity  
   */  
    
  for (var file in modules) {  
    modules[file] = {  
      source: modules[file],  
      loaded: false,  
      exports: {}  
    }  
  }  
    
  /**  
   * add aliases to the module map  
   */  
    
  for (var alias in aliases) {  
    if (alias in modules) continue  
    modules[alias] = modules[aliases[alias]]   
  }  
    
  /**  
   * Require the given path.  
   *  
   * @param {String} path  
   * @param {String} parent  
   * @return {Any} module.exports  
   */  
    
  function require (path, parent){  
    parent || (parent = '/')  
    
    var fullpath = resolve(parent, path)  
    if (!fullpath) throw Error('failed to require '+path+' from '+parent)  
    if (fullpath in aliases) fullpath = aliases[fullpath]  
    var module = modules[fullpath]  
    
    if (!module.loaded) {  
      module.loaded = true  
      Function(  
        'module',  
        'exports',  
        'require',  
        // sourceURL tells the browser we are evaling a file  
        module.source + '\n//@ sourceURL=' + encodeURI(prettyPath(fullpath))  
      ).call(module.exports, module, module.exports,  
        // relative `require` function  
        function(path){  
          var base = dirname(fullpath)  
          if (path[0] == '.') path = join(base, path)  
          return require(path, base)  
        }  
      )  
    }  
    return module.exports  
  }  
    
  function prettyPath(path){  
    if (/github\.com\/([^\/]+)\/([^\/]+)\/tarball\/([^\/]+)\/(.*)/.test(path)) {  
      return RegExp.$1+'/'+RegExp.$2+'@'+RegExp.$3 + '/' + RegExp.$4  
    }  
    return path  
  }  
    
  /**  
   * Figure out what the full path to the module is  
   *  
   * @param {String} base, the current directory  
   * @param {String} path, what was inside the call to require  
   * @return {String}  
   * @api private  
   */  
    
  function resolve (base, path) {  
    // absolute  
    if (/^\/|(?:\w+:\/\/)/.test(path)) {  
      return complete(path)  
    } else if (/^\./.test(path)) {  
      // todo: fix join for urls  
      return complete(join(base, path))  
    }  
    
    // walk up looking in node_modules  
    while (true) {  
      var res = complete(join(base, 'node_modules', path))  
      if (res) return res  
      if (base == '/' || base == '.') break  
      base = dirname(base)  
    }  
  }  
    
  /**  
   * get the parent directory path  
   *  
   * @param {String} path  
   * @return {String}  
   */  
    
  function dirname(path){  
    var i = path.lastIndexOf('/')  
    if (i < 0) return '.'  
    return path.slice(0, i) || '/'  
  }  
    
  /**  
   * Clean up a messy path  
   *  
   *   normalize('/foo//baz/quux/..') // => '/foo/baz'  
   *  
   * @param {String} path  
   * @return {String}  
   */  
    
  function normalize(path){  
    var segs = path.split('/')  
    if (segs.length <= 1) return path  
    var res = []  
    var up = 0  
    
    for (var i = 0, len = segs.length; i < len; i++) {  
      var seg = segs[i]  
      if (seg === '' || seg === '.') continue  
      if (seg === '..') up++, res.pop()  
      else up--, res.push(seg)  
    }  
    
    if (up > 0) {  
      if (path[0] == '/') return '/'  
      res = '..'  
      while (--up) res += '/..'  
      return res  
    }  
    return path[0] == '/'  
      ? '/' + res.join('/')  
      : res.join('/') || '.'  
  }  
    
  /**  
   * Concatenate a sequence of path segments to generate one flat path  
   *   
   * @param {String} [...]  
   * @return {String}  
   */  
    
  function join(path){  
    for (var i = 1, len = arguments.length; i < len; i++) {  
      path += '/' + arguments[i]  
    }  
    return normalize(path)  
  }  
    
  /**  
   * Produce an ordered list of paths to try  
   *   
   * @param {String} path  
   * @return {Array} of path  
   * @private  
   */  
    
  function completions(path){  
    // A directory  
    if (path.match(/\/$/)) {  
      return [  
        path+'index.js',  
        path+'index.json',  
        path+'package.json'  
      ]  
    }  
    // could be a directory or a file  
    return [  
      path,  
      path+'.js',  
      path+'.json',  
      path+'/index.js',  
      path+'/index.json',  
      path+'/package.json'  
    ]  
  }  
    
  /**  
   * find the first matching path completion  
   *  
   * @param {String} path  
   * @return {String} full path of the module  
   */  
    
  function complete(path) {  
    return completions(path).filter(function (path) {  
      return path in modules  
    })[0]  
  }  
  
  return require("/example.html-1.js")
})
</script>